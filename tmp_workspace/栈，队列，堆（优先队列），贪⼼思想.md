# 栈，队列，堆（优先队列），贪心思想



## 栈

### 栈的定义

栈是一种只允许在一端进行插入、删除的线性表。

> 栈底是固定的，不允许插入和删除的一端。栈顶是能够进行插入和删除的一端。
>
> 所以栈是先进后出的线性表。

### 栈的操作

- StackInit：初始化栈 
- StackPush：入栈 
- StackPop：出栈 
- StackTop：获取栈顶元素 
- StackEmpty：检测栈是否为空
- StackDestroy：销毁栈 

### 栈的实现


#### 数组模拟栈

- 用top表示栈顶所在的索引。初始时，top = -1。表示没有元素。

- push x ：栈顶所在索引往后移动一格，然后放入x。st[++top] = x。

- pop : top 往前移动一格。top–。

- empty ：top 大于等于 0 栈非空，小于 0 栈空。top == -1 ? “YES” : “NO”

- query ： 返回栈顶元素。st[top]

#### stl实现

头文件：#include <stack>

- empty() 堆栈为空则返回真

- pop() 移除栈顶元素

- push() 在栈顶增加元素

- size() 返回栈中元素数目

- top() 返回栈顶元素



## 队列

### 队列的定义

队列是一种一端进行插入，另一端进行删除的线性表。

>  队头是进行删除操作的一端。队尾是进行插入操作的一端。
>
> 所以队列是先进先出的线性表。

### 队列的操作

- QueueInit：初始化队列
- QueuePush:队尾入队列 
- QueuePop:队头出队列 
- QueueFront:获取队列头部元素 
- QueueBack:获取队列队尾元素 
- QueueEmpty: 检测队列是否为空
- QueueDestroy:销毁队列 

### 队列的实现

#### 数组模拟队列

- 用一个数组 q 保存数据。

- 用 hh 代表队头，q[hh] 就是队头元素， q[hh + 1] 就是第二个元素。

- 用 tt 代表队尾， q[tt] 就是队尾元素， q[tt + 1] 就是下一次入队，元素应该放的位置。

- [hh, tt] 左闭右闭，代表队列中元素所在的区间。

- 出队pop：因为 hh 代表队头，[hh, tt] 代表元素所在区间。所以出队可以用 hh++实现，hh++后，区间变为[hh + 1, tt]。

- 入队push：因为 tt 代表队尾，[hh, tt] 代表元素所在区间。所以入出队可以用 tt++实现，tt++后，区间变为[hh, tt + 1], 然后在q[tt+1]位置放入入队元素。

- 是否为空empty：[hh, tt] 代表元素所在区间，当区间非空的时候，对列非空。也就是tt >= hh的时候，对列非空。

- 询问队头query：用 hh 代表队头，q[hh] 就是队头元素，返回 q[hh] 即可。

#### stl实现

头文件：#include <queue>

- empty：检测队列是否为空

- size：返回队列中有效元素的个数

- front：返回队头元素的引用

- back：返回队尾元素的引用

- push_back：在队列尾部入队列

- pop_front：在队列头部出队列



## 栈与队列的区别

**栈：**仅在栈顶进行插入、删除，栈底不进行操作。并且数据是先进后出。

**队列：**队头进行删除，队尾进行插入。数据是先进先出。



## 堆（优先队列）

### 定义

堆是一种**树形结构**，树的根是堆顶，堆顶始终保持为所有元素的最优值。有大根堆和小根堆，大根堆的根节点是最大值，小根堆的根节点是最小值。堆一般用二叉树实现，称为二叉堆。

### 操作

**empty**
返回堆是否为空

**top**
直接返回根节点的值，时间复杂度 O(1)

**push**
将新元素添加在数组最后面，若它比父节点小则不断与其父节点交换，使得堆重新满足父节点比子节点存储的数都要小（自下而上），时间复杂度 O(log⁡n)

**pop**
弹出根节点，并让堆依然符合原来的性质。首先交换根节点和数组中最后一个元素，再去掉最后一个元素。若新根节点比子节点大，则不断与较小子节点交换，直到重新满足条件（自上而下），时间复杂度 $O(log⁡n)$

### 堆的实现

#### 数组模拟堆

- heap_swap：交换两个元素
- heap_down：向下调整
- heap_up：向上调整

#### stl实现（优先队列）


头文件：#include <queue>

- empty：检测堆是否为空
- size：返回堆中有效元素的个数
- top：返回堆顶元素的引用
- push：在堆中插入元素
- pop：删除堆顶元素
- make_heap：将一个数组转化为堆
- push_heap：插入元素并调整堆
- pop_heap：删除堆顶元素并调整堆
- sort_heap：将堆排序
- is_heap：判断是否为堆

### 堆排序（Heap Sort）

堆排序是一种利用堆这种数据结构实现的排序算法。其步骤如下：

1. **构建最大堆（或最小堆）**：将数组构造成一个最大堆（或最小堆）。
2. **交换堆顶元素和最后一个元素**：将堆顶元素（最大值或最小值）与数组最后一个元素交换位置。
3. **调整堆**：将堆顶元素移除，并调整剩余部分以维持堆的性质。
4. **重复上述步骤**：重复上述步骤，直到数组排序完成。

STL 提供了 `priority_queue` 和 `make_heap` 等函数来实现堆的操作。



## 贪心思想

### 定义

指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法。
> 贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果。

### 性质
1. 最优子结构性质
最优子结构性质是指问题的最优解包含了其子问题的最优解。

也就是说，在使用贪心算法解决问题时，我们可以通过子问题的最优解来构建全局最优解。通过将问题分解为各个子问题，并以递归的方式解决子问题，最终可以获得整体的最优解。

2. 贪心选择性质
贪心选择性质是指在每一步选择中，都采取当前最好的选择，而不考虑未来的影响。也就是说，我们每次做出局部最优的选择，希望这些局部最优解最终能够导致全局最优解。

### 例题

#### luogu P1223

#### 题意
n个人排队接水，每个人接水的时间为t[i]，求最短的平均等待时间。

#### 思路

贪心思想：每次选择等待时间最短的人接水。
> 证明：假设有两个人a和b，a的接水时间小于b，如果a先接水，那么a的等待时间为0，b的等待时间为a的接水时间，如果b先接水，那么a的等待时间为b的接水时间，b的等待时间为0。所以应该选择等待时间最短的人先接水。

#### luogu P1080

#### 题意
恰逢 H 国国庆，国王邀请n位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 n 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。
国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。

#### 思路
贪心思想：按每个大臣左右手乘积除以右手的值排序，然后按照排序后的顺序计算每个大臣的奖赏。

> 证明：假设有两个大臣a和b，a的左右手乘积除以右手的值小于b，如果a在b前面，那么a的奖赏为a的左右手乘积除以右手的值，b的奖赏为b的左右手乘积除以右手的值，如果b在a前面，那么a的奖赏为a的左右手乘积除以右手的值，b的奖赏为b的左右手乘积除以右手的值。所以应该按照左右手乘积除以右手的值排序。